# 19팀 취뽀 스터디 5주차 (2023.11.06 ~ 2023.11.12)

---
## 일시
### 23.11.09.목(20:30~22시)
- 프로그래머스 라이브코딩 주제 : [LV3. 코딩테스트공부 - DP](https://school.programmers.co.kr/learn/courses/30/lessons/118668)
- 면접 대비 주제 : 자바 (예상질문 및 모범답안, 꼬리질문 논의 및 공유)
- 참여자: 조현수, 최병호, 김상훈, 김동역, 장진영
        
---
## 기술면접 질문

### 1. 김동역 - SOLID 원칙

**SOLID 원칙**
SOLID란 프로그래머의 바이블이라 할 수 있는 클린 코드의 저자이기도 한 로버트 C. 마틴이 발표한 5가지의 객체지향 설계 원칙의 첫 글자를 순서대로 가져온 것이다.
**S - 단일 책임 원칙**<br>
단일 책임 원칙(Single responsibility principle)은 하나의 클래스는 단 하나의 책임만 져야 한다는 의미를 뜻한다. <br>
하나의 목표만을 위해 클래스를 작성한다면 유지보수 및 가시성을 높게 유지할 수 있게 된다.<br>
**O - 개방 폐쇄 원칙**<br>
개방 폐쇄 원칙(Open-closed principle)은 소프트웨어 컴포넌트는 확장에 관해 열려 있고 수정에 관해 닫혀 있어야 한다는 의미이다.<br>
다른 개발자가 단순히 클래스를 확장하기만 해도 클래스의 동작을 수정할 수 있도록 클래스를 설계하고 작성해야 한다는 의미이다.<br>
즉 수정이 필요한 제약 사향을 클래스에 포함해서는 안 되며, 다른 개발자가 이 클래스를 확장하기만 하면 원하는 작업이 가능하도록 만들어야 한다.<br>
**L - 리스코프 치환 원칙**<br>
리스코프 치환 원칙(Liskov substitution principle)은 미국의 컴퓨터 과학자 바바라 리스코프가 발표한 원칙으로, <br>
파생 타입은 반드시 기본 타입을 완벽하게 대체할 수 있어야 한다는 의미이다. 즉, 모든 자식 클래스의 객체가 부모 클래스의 객체와 반드시 같은 방식으로 동작해야 한다.<br>
이렇게 구현하면 타입 변환 후에 뒤따라오는 런타임 타입 식별에 유용하다.
**I - 인터페이스 분리 원칙**<br>
인터페이스 분리 원칙(Interface segregation principle)은 클라이언트가 사용하지 않을 불필요한 메서드를 강제로 구현하게 해서는 안된다는 의미이다.<br>
클라이언트가 사용하지 않을 메서드를 강제로 구현해야 하는 일이 없을 때까지 하나의 인터페이스를 2개 이상의 인터페이스로 분할해야 한다는 의미이다.<br>
**D - 의존관계 역전 원칙**<br>
의존관계 역전 원칙은 구체화가 아닌 추상화에 의존해야 한다는 의미이다.<br>
구상된 모듈에 의존하는 새로운 구상 모듈 대신, 구상 모듈을 결합하기 위해 추상 계층에 의존해야 한다는 것이다. <br>
이를 위해 모든 구상 모듈은 추상적인 내용만 노출해야 하며, 이를 통해 구상 모듈들은 분리된 상태를 유지하면서 다른 구상 모듈에 대해 확장할 수 있다.<br>
##### 꼬리 질문
구체화가 아닌 추상화에 의존해야 한다고 했는데, 그렇다면 객체지향에서 추상화의 개념은 무엇인가?<br>
추상화란 객체지향 프로그래밍의 중요 개념 중 하나로, 객체지향 프로그래밍의 객체는 사용자에게 높은 수준의 작업 집합만 노출하고 <br>
이 작업의 내부 구현 내용은 숨겨야 합니다. 추상화하여 구현하면 사용자는 어플리케이션이 일을 수행하는 방법이 아닌 수행하는 일 자체에 집중할 수 있게 됩니다. <br>
중요한 내용만 노출하여 복잡성을 줄이고 보안을 유지하게 되는 것입니다.

### 2. 조현수 - call by reference 와 call by value의 차이에 대해 설명해주세요.

`call by value` 와 `call by reference` 는 함수 호출 시 인자 전달 방식의 차이를 나타냅니다.<br>
`call by value` 는 함수 호출 시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달 합니다.<br>
따라서 함수 내에서 인자 값이 변경되더라도 원래 변수에는 영향을 미치지 않습니다.
반면 `call by reference`는 함수 호출 시 인자로 전달되는 변수의 레퍼런스(주소)를 전달한다.
이 경우 함수 내에서 인자 값이 변경되면 원래 변수의 값도 함께 변경됩니다.
##### 꼬리질문1.  자바에서는 어떤방식을 사용하나요
자바에서는 기본형 변수를 함수의 인자로 전달할 때 `call by value` 방식을 사용합니다. <br>
참조형 변수를 전달할 때도 사실 `call by value` 방식을 사용하지만, 
이때 전달되는 값은 객체의 참조 주소입니다. 
따라서 함수 내에서 해당 주소의 객체를 변경하면 호출자에게도 그 영향이 반영됩니다. 
하지만, 새로운 객체를 할당하는 등 참조 자체를 변경하는 경우 호출자의 원본 참조에는 영향을 주지 않습니다.

##### 추가질문. 클래스 변수, 지역 변수, 인스턴스 변수의 차이에 대해 설명해주세요

`클래스 변수`는 `static` 키워드를 사용해 선언되며, 클래스 레벨에서 정의가 됩니다.<br>
이는 해당 클래스의 모든 객체가 공유하며, JVM 의해 클래스가 로드될때 메모리(Method Area)에 할당됩니다.<br>
(객체를 생성하지 않고도 클래스 이름을 통해 접근 가능)<br>

`인스턴스 변수`는 객체가 생성될 때마다 힙(`heap`) 영역에 매번 새로 생성되어 각 객체마다 독립적인 값을 가지게 됩니다.<br>

`지역변수`는 메서드나 블록 내에서 선언되며, 해당 영역 내에서만 사용할 수 있습니다. 이는 스택 영역에 할당되며,<br>
메서드나 블록 실행이 종료되면 메모리에서 해제됩니다.(초기화 하지 않으면 사용 불가)<br>
지역 변수는 메서드가 호출될 때마다 스택(`stack`) 영역에 새로 생성되고 메서드 호출이 종료되면 소멸합니다.<br>
반면에 클래스 변수는 static Area에 한 번만 생성되어 해당 클래스의 모든 객체가 공유합니다.<br>
멤버변수는 지역 변수와 다르게 각 타입의 기본 값으로 자동 초기화<br>
참고 : 클래스 변수, 인스턴스 변수 둘다 멤버 변수<br>
참고 : 인스턴스 변수는 객체가 생성될 때마다 힙(heap) 영역에 매번 새로 생성되며, 각 객체마다 독립적인 변수를 가지게 됩니다.<br>


---

## 라이브 코딩 주제 및 코드

### DP를 사용한 풀이 (스터디 팀 전원 풀이 실패 - 답안참고)
```java
public class Solution {

    public static int solution(int alp, int cop, int[][] problems) {
        // 초기 알고리즘 레벨과 코딩 레벨의 최댓값을 설정
        int maxAlp = alp;
        int maxCop = cop;

        // 주어진 문제들을 순회하며 최댓값 갱신
        for (int[] problem : problems) {
            maxAlp = Math.max(problem[0], maxAlp);
            maxCop = Math.max(problem[1], maxCop);
        }

        // DP 테이블 초기화
        int[][] dp = new int[maxAlp + 1][maxCop + 1];
        for (int i = 0; i <= maxAlp; i++) {
            for (int j = 0; j <= maxCop; j++) {
                // 초기값으로 10000 설정
                dp[i][j] = 10000;
            }
        }
        // 시작점 초기화
        dp[alp][cop] = 0;

        // DP 테이블 채우기
        for (int i = alp; i <= maxAlp; i++) {
            for (int j = cop; j <= maxCop; j++) {
                int minAlp = Math.min(i + 1, maxAlp);
                int minCop = Math.min(j + 1, maxCop);

                // 알고리즘 공부 레벨을 1 증가시키는 경우
                dp[minAlp][j] = Math.min(dp[minAlp][j], dp[i][j] + 1);
                // 코딩 레벨을 1 증가시키는 경우
                dp[i][minCop] = Math.min(dp[i][minCop], dp[i][j] + 1);

                // 주어진 문제들을 풀 경우의 DP 값 갱신
                for (int[] problem : problems) {
                    if (i >= problem[0] && j >= problem[1]) {
                        int newAlp = Math.min(maxAlp, i + problem[2]);
                        int newCop = Math.min(maxCop, j + problem[3]);
                        dp[newAlp][newCop] =
                            Math.min(dp[newAlp][newCop], dp[i][j] + problem[4]);
                    }
                }
            }
        }
        // 최종 결과값 반환
        return dp[maxAlp][maxCop];
    }
}
```

---

### 6주차 계획 - 23.11.02.목(20시~)
- 프로그래머스 라이브코딩 (주제 : DFS)
- 면접 대비 주제 : 스프링부트
    
