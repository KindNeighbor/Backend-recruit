# 19팀 취뽀 스터디 2주차 (2023.10.16 ~ 2023.10.22)

---
## 일시
### 23.10.19.목(18~20시)
- 프로그래머스 라이브코딩 주제 : [가장 큰 정사각형 찾기 LV.2](https://school.programmers.co.kr/learn/courses/30/lessons/12905)
- 면접 대비 주제 : 네트워크 (예상질문 및 모범답안, 꼬리질문 논의 및 공유)
- 참여자: 조현수, 최병호, 김상훈, 김동역
        
---
## 기술면접 질문
### 1. OSI 7계층 이란 무엇인가요? (조현수)

OSI 7계층은 네트워킹에서의 통신 프로세스를 이해하기 위한 표준 모델입니다.
* 7계층(application layer, 응용계층) : 최종 목적지로 응용프로그램과 연관해 서비스를 수행하는 계층입니다. 이메일 , 웹사이트 조회 등 어플리케이션 서비스 제공(HTTP,FTP,DNS 등이 있다)
* 6계층(Presentation layer, 표현 계층) : 데이터의 암호화, 압축,변환등을 담당하는 계층입니다.(JPEG, MPEG 등)
* 5계층(Session layer, 세션 계층) : 통신 세션을 구성하고 유지하기 위한 기능을 담당하는 계층입니다.(API, SOCKET)
* 4계층(Transport layer, 전송 계층) : 종단 간의 사용자들에게 신뢰성 있는 데이터를 전달하기 위한 계층입니다.단위 세그먼트 or 데이터 그램(TCP,UDP)
* 흐름제어 : 송신측, 수신측 사이의 데이터 처리 속도 차이 제어
* 혼잡제어 : 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도 제어
* 오류제어 : 오류 검출 및 잘못된 패킷 재전송 등 관리
* 3계층(Network layer, 네트워크 계층) : IP를 지정하고 라우터로 경로를 선택해 (네트워크를 통해) 패킷을 전송하는 계층(Router), 단위 패킷
* 2계층(Data Link Layer, 데이터 링크 계층) : 프레임 단위의 데이터 전송과 MAC 주소를 이용한 통신을 처리하는 계층.단위 프레임. 신뢰성 있는 전송 위해 에러 검출 및 흐름제어 담당(이더넷 프로토콜, 스위치)
* 1계층(Physical Layer, 물리 계층) : 데이터를 전기 신호로 변환 및 제어하는 계층, 단위 비트(리피터 ,허브)

전송 계층은 전체 통신 경로(최초 송신자와 최종 수신자 간)를 걸쳐 데이터의 안정성 보장, 데이터 링크 계층은 직접 연결된 두 장치간의 데이터 전송 관리

#### 꼬리질문 1 - 왜 각 계층은 나누어져 있을까요??
통신이 일어나는 과정을 단계별로 잘 확인할 수 있고, 특정 계층에 문제가 말생하면 해당 계층만을 수정하거나 조정함으로서 다른 계층의 장비나 소프트웨어에 영향을 미치지 않고 효율적으로 문제 해결 가능

---

### 2. HTTP와 HTTPS의 차이점은 무엇인가요? (최병호)

HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 조회될 수 있습니다.
이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다.
HTTPS는 SSL의 껍질을 덮어쓴 HTTP라고 할 수 있습니다.

※ SSL(Secure Socket Layer) 인터넷을 통해 전달되는 정보를 보호하기 위해 개발한 통신 규약

HTTP는 원래 TCP와 직접 통신했지만, HTTPS에서 HTTP는 SSL과 통신하고 SSL이 TCP와 통신함으로써 암호화와 증명서, 안전성 보호를 이용할 수 있게 됩니다.

--- 

### 3. TCP와 UDP (김동역)
TCP와 UDP는 전송 계층(OSI 7계층 중 4계층)에서 사용하는 대표적인 프로토콜입니다.

**TCP란?**
연결형 서비스를 지원하고 데이터의 신뢰성을 보장합니다. 또한, 다음과 같은 특징이 있습니다.
* 송신부와 수신부의 연결을 확인하는 연결형 서비스다.
* 패킷 교환 방식은 패킷이 전달되는 회선이 정해져 있는 가상 회선 방식이다.
* 패킷의 전송 순서가 보장된다.
* 패킷의 수신 여부를 확인한다.
* 송신부와 수신부는 1:1 통신을 한다.
* 데이터 손실이 없음을 보장하므로 신뢰성이 높다.
* 데이터의 송수신 속도가 느리다.

이외에, TCP는 연결형 서비스를 지원하기 위해 송신부와 수신부를 연결하는 과정을 거치는데 연결을 시작할 때(세션을 수립할 때)에는 3-way handshaking(핸드셰이킹, 요청과 응답을 총 3번 주고받음)을, 종료할 때에는 4-way handshaking을 합니다.

**TCP 제어 방법**
TCP의 데이터 신뢰성을 보장하기 위한 제어 방법으로는 흐름 제어, 혼잡 제어, 오류 제어가 있습니다.
* 흐름 제어 : 데이터 송신부와 수신부에서 데이터 처리 속도의 차이 때문에 생기는 데이터 손실을 방지하는 방법
* 혼잡 제어 : 송신부의 데이터 전달 속도와 네트워크 속도 차이로 데이터 손실이 발생하는 것을 방지하기 위한 방법
* 오류 제어 : 통신 중 데이터에 오류 또는 유실이 발생할 때 데이터의 신뢰성을 보장하기 위해 오류를 제어하는 방식

**UDP란?**
송신부와 수신부 간 연결을 지원하지 않고 데이터그램 형태의 통신을 지원합니다. 따로 연결 과정 없이 패킷을 바로 송수신하게 되며, 신뢰성이 낮지만 속도가 빠르다는 장점이 있습니다. 특징은 다음과 같습니다.
* 송신부와 수신부의 연결이 보장되지 않는 비연결형 서비스다.
* 패킷이 서로 다른 회선으로 교환될 수 있는 데이터그램 패킷 교환 방식이다.
* 송신부에서 전달한 패킷 순서와 수신부에서 받은 패킷 순서가 다를 수 있다.
* 패킷의 수신 여부를 확인하지 않는다.
* 1:1, 1:N, N:N 통신 모두 가능하다.
* 데이터의 신뢰성이 낮다.
* 데이터의 전송 속도가 빠르다.

UDP는 신뢰성이 낮지만, 최소한의 신뢰성을 보장하기 위해 checksum(체크섬) 방식으로 오류를 검출합니다. 체크섬은 데이터의 무결성을 보장하는 간단한 방법으로, 체크섬을 만들기 위한 데이터를 모두 더한 뒤 오버플로되는 자릿수를 떼어 데이터에 다시 더한 후 1의 보수를 취해서 만듭니다. 이를 송신부에 넣어 수신부로 보내 수신부에서 송신부와 동일한 체크섬 값이 나오는지 확인하는 방식입니다. 그러나 이 방법으로 100% 오류를 검출할 수 있는 것은 아니며, UDP의 체크섬은 선택 사항이므로 보내지 않을 수도 있습니다.

#### 꼬리 질문 : TCP 방식과 UDP 방식을 각각 사용할 수 있는 서비스는 어떤 것이 있을까요?
TCP 방식은 연결 과정이 필요하며, 순서가 보장되고 신뢰성이 높습니다. 그러므로 파일 전송(FTP) 등 보내는 내용의 신뢰성이 중요한 서비스에서 사용할 수 있습니다.
UDP 방식은 연결 과정이 필요 없고, TCP 방식에 비해 신뢰성을 확인하는 과정이 필요 없으므로 네트워크의 부하가 적고 속도가 빠릅니다. 그러므로 신뢰성보다는 데이터가 끊기지 않는 연속성을 더 중요하게 고려해야 하는 스트리밍(음악, 영상 등) 서비스에서 사용할 수 있습니다. 

### 4. TLS/SSL HandShake - HTTPS에서 클라이언트와 서버간 통신 전 SSL 인증서로 신뢰성 여부를 판단하기 위해 연결하는 방식 (김상훈)
**진행 순서**
클라이언트는 서버에게 client hello 메시지를 담아 서버로 보낸다. 이때 암호화된 정보를 함께 담는데, 버전, 암호 알고리즘, 압축 방식 등을 담는다.
서버는 클라이언트가 보낸 암호 알고리즘과 압축 방식을 받고, 세션 ID와 CA 공개 인증서를 server hello 메시지와 함께 담아 응답한다. 이 CA 인증서에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, 클라이언트에서 handshake 과정 속 암호화에 사용할 공개키를 담고 있다.
클라이언트 측은 서버에서 보낸 CA 인증서에 대해 유효한 지 CA 목록에서 확인하는 과정을 진행한다.
CA 인증서에 대한 신뢰성이 확보되었다면, 클라이언트는 난수 바이트를 생성하여 서버의 공개키로 암호화한다. 이 난수 바이트는 대칭키를 정하는데 사용이 되고, 앞으로 서로 메시지를 통신할 때 암호화하는데 사용된다.
만약 2번 단계에서 서버가 클라이언트 인증서를 함께 요구했다면, 클라이언트의 인증서와 클라이언트의 개인키로 암호화된 임의의 바이트 문자열을 함께 보내준다.
서버는 클라이언트의 인증서를 확인 후, 난수 바이트를 자신의 개인키로 복호화 후 대칭 마스터 키 생성에 활용한다.
클라이언트는 handshake 과정이 완료되었다는 finished 메시지를 서버에 보내면서, 지금까지 보낸 교환 내역들을 해싱 후 그 값을 대칭키로 암호화하여 같이 담아 보내준다.
서버도 동일하게 교환 내용들을 해싱한 뒤 클라이언트에서 보내준 값과 일치하는 지 확인한다. 일치하면 서버도 마찬가지로 finished 메시지를 이번에 만든 대칭키로 암호화하여 보낸다.
클라이언트는 해당 메시지를 대칭키로 복호화하여 서로 통신이 가능한 신뢰받은 사용자란 걸 인지하고, 앞으로 클라이언트와 서버는 해당 대칭키로 데이터를 주고받을 수 있게 된다.
#### 꼬리 질문 : HandShake 과정에서 사용되는 암호화는 어떤 종류인가요?
'handshake' 그 자체는 비대칭 암호화를 사용합니다. 공개키와 개인키도 각각 별도로 사용됩니다.
비대칭 암호화 시스템은 높은 오버헤드를 가지고 있기 때문에 모든 보안 과정을 제공하는 데 사용할 수 없습니다. 그래서 공개키는 handshake 하는 동안 암호 해독을 위한 암호화 및 개인키로 사용되며 서버와 클라이언트가 각각 새로 생성한 공유키를 설정하고 교환하게 합니다.
세션 자체는 공유키를 사용하여 대칭 암호화를 수행하기 때문에 실제 연결에서 오버 헤드를 줄여줍니다. 

---
## 라이브 코딩 주제 및 코드

### DP 배열을 사용한 풀이 (김동역, 김상훈 ,조현수)
```java
import java.util.*;
class Solution{
    public int solution(int [][]board){
        int r = board.length;
        int c = board[0].length;
        
        if(r==1 || c==1) return 1;
        
        int[][] dp = new int[r][c];
        //첫열복사
        dp[0] = Arrays.copyOfRange(board[0],0,c);
        //첫행복사
        for(int i = 0 ; i < r ; i++){
            dp[i][0] = board[i][0];
        }
        //보드 반복 돌면서 만약 1이면? 전열/전행/대각선전 값 확인
        //최솟값에 1 더해서 현재 최대 사각형 크기 (길이)확인. 
        //쭉쭉 돌면서 다름 대각선에 도달했을때 다시 크기(길이) 확인
        //가장큰 값 제곱 - 사각형크기
        int maxLen = Integer.MIN_VALUE;
        
        for(int i = 1; i < r ; i++){
            for(int j = 1; j < c ;j++){
                if(board[i][j]==1){
                    dp[i][j] = Math.min(
                        dp[i-1][j-1], //대각선전
                        Math.min(dp[i][j-1],dp[i-1][j]) // 전행/전열
                    )+1; //일더함
                    maxLen = Math.max(maxLen,dp[i][j]);
                }
            }
        }       
        return maxLen*maxLen;
    }
}
```

### 본 배열 자체를 수정하는 풀이 (최병호)
```java
class Solution {
    public int solution(int[][] board) {
        int r = board.length;
        int c = board[0].length;

        if (r == 1 || c == 1)
            return 1;

        int maxLen = 0;

        for (int i = 1; i < r; i++) {
            for (int j = 1; j < c; j++) {
                if (board[i][j] == 1) {
                    int min = Math.min(board[i - 1][j - 1], Math.min(board[i][j - 1], board[i - 1][j]));
                    board[i][j] = min + 1;
                    maxLen = Math.max(maxLen, board[i][j]);
                }
            }
        }
        return maxLen * maxLen;
    }
}
```
---

### 3주차 계획 - 23.10.26.목(21시~)
- 프로그래머스 라이브코딩 (주제 : DFS)
- 면접 대비 주제 : OS (예상질문 및 모범답안, 꼬리질문 논의 및 공유)
    
