# 19팀 취뽀 스터디 4주차 (2023.10.30 ~ 2023.11.05)

---
## 일시
### 23.11.01.목(20:30~22시)
- 프로그래머스 라이브코딩 주제 : [Lv2. 택배 배달과 수거하기 ](https://school.programmers.co.kr/learn/courses/30/lessons/150369)
- 면접 대비 주제 : 동시성 제어 (예상질문 및 모범답안, 꼬리질문 논의 및 공유)
- 참여자: 조현수, 최병호, 김상훈, 김동역, 장진영
        
---
## 기술면접 질문

### 1. 김상훈 - 트랜잭션 고립수준 명령어

- 다중 사용자 환경에서 둘 이상의 트랜잭션이 발생하여 동시에 DB의 데이터를 읽으며 수정이 된다면
`dirty read`, `non-repeatable read`, `phantom read` 등 DB상의 문제를 일으킬 수 있습니다. <br>
그를 해결하기 위해서 사용하는 락보다는 완화된 해결책이 바로 트랜잭션 고립 수준 명령어입니다.<br>

**[ READ UNCOMMITTED ]**
고립 수준이 Level 0으로 가장 낮은 명령어로, 자신의 데이터에 아무런 공유락을 걸지 않는다.<br>
**[ READ COMMITTED ]**
고립 수준이 Level 1인 명령어로, 오손 페이지의 참조를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만 트랜잭션이 끝나기 전에라도 해지 가능하다.<br>
**[ REPEATABLE READ ]**
고립 수준이 Level 2인 명령어로, 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료될 때까지 유지하여 다른 트랜잭션이 다신의 데이터를 갱신(Update)할 수 없도록 한다.<br>
**[ SERIALIZABLE ]**
고립 수준이 Level 3으로 가장 높은 명령어로, 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리된다.<br>
고립 수준에는 위 4가지가 있습니다.
고립 수준마다 방지할 수 있는 오류가 달라집니다. 하지만 고립 수준이 올라갈 수록 성능저하가 생길 수 있습니다,<br>

### 2. 김동역 - 동시성 제어란?

동시에 실행되는 여러 개의 트랜잭션이 작업을 성공적으로 마칠 수 있도록 트랜잭션의 실행 순서를 제어하는 기법이다.<br>
**동시성 제어의 정의**
다중 사용자 환경을 지원하는 데이터 베이스 시스템에서 여러 트랜잭션들이 성공적으로 동시에 실행될 수 있도록 지원하는 기능<br>
다중 사용자 환경을 지원하는 DB system의 경우 필수적으로 지원해야 하는 기능으로 병행제어라고도 한다.<br>

**동시성 제어의 목적**
- 트랜잭션의 직렬성 보장
- 공유도 최대, 응답 시간 최소, 시스템 활동의 최대 보장
- 데이터의 무결성 및 일관성 보장
- 동시성 제어를 하지 않을 경우 발생하는 문제
 
**갱신 손실 (Lost Update)**
- 하나의 트랜잭션이 갱신한 내용을 다른 트랜잭션이 덮어씀으로써 갱신이 무효화가 되는 것을 의미
- 두 개이상 트랜잭션이 한 개의 데이터를 동시에 갱신(Update)할 때 발생
**현황파악오류 (Dirty Read)**
- 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션2가 작업한 중간 데이터를 읽기 때문에 발생하는 문제
- 작업중인 트랜잭션 2가 작업을 Rollback한 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출한다.
**모순성 (Inconsistency)**
- 다른 트랜잭션들이 해당 항목 값을 갱신하는 동안 한 트랜잭션이 두 개의 항목 값 중 어떤 것은 갱신되기 전의 값을 읽고 다른 것은 갱신된 후의 값을 읽게 되어 데이터의 불일치가 발생하는 상황
**연쇄복귀 (Cascading Rollback)**
- 두 트랜잭션이 동일한 데이터 내용을 접근할 때 발생
- 한 트랜잭션이 데이터를 갱신한 다음 실패하여 Rollback 연산을 수행하는 과정에서 갱신과 Rollback 연산을 실행하고 있는 사이에 해당 데이터를 읽어서 사용할 때 발생할 수 있는 문제

##### 꼬리 질문 - 동시성을 제어할 수 있는 기법에는 어떤 것들이 있나요?
트랜잭션이 데이터에 락을 거는 락킹(locking) 기법, 시스템에서 생성하는 고유 시간 번호인 타임스탬프를 트랜잭션에 부여하여 접근 순서를 보장하는 타임스탬프(timestamp) 기법,<br>
트랜잭션을 수행하고 종료할 때 적합성을 검증하여 최종 반영하는 적합성 검증(validation) 이 있습니다.

### 3. 조현수 - DB Lock에 대해 설명해주세요.

DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법으로, <br>
데이터에 접근하기 전에 Lock을 요청해서 Lock이 허락되면 해당 데이터에 접근할 수 있도록 하는 기법입니다.<br>

**비관적락**(충돌이 일어날거라 가정)은 트랜잭션이 데이터에 접근하기 전에 해당 데이터에 대한 락을 얻어와 <br>
다른 트랜잭션의 동시 접근을 제어하는 방식으로, 공유락과 베타락이 존재합니다.

- **공유락**은 사용중인 데이터를 다른 트랜잭션이 읽는것은 허용하나 쓰기는 허용하지 않는 방식이고,<br>
- **베타락**의 경우엔 읽기 쓰기 둘다를 허용하지 않는 방식입니다.

**낙관적락**(충돌 없을거라 가정)은 데이터 갱신 시 충돌이 발생하지 않을 것이라 가정하는 방식으로,<br> 
초기 데이터 접근 시 락을 걸지 않고, 실제 데이터 변경 시점에 충돌 여부를 검사하게 됩니다.<br>
각 레코드에 버전 번호나 타임스탬프를 추가해서, 데이터가 변경될 때 마다 이 값을 증가시킵니다. <br>
이후 트랜잭션이 커밋 시점에 원래의 버전 번호나 타임스탬프와 현재 값을 비교하여 변경이 있었는지 확인하게 됩니다.<br>
이때 만약 다른 트랜잭션에 의해 값이 변경되었다면, 충돌을 감지하게 되고, 이에 따른 조치(롤백)를 취하게 됩니다.<br>

##### 꼬리질문 - 어떠한 경우에 낙관적락을 사용하고, 어떠한 경우 비관적락을 사용하나요?
낙관적 락은 데이터 충돌의 빈도가 낮고, 높은 동시성이 요구될 때 적합합니다. 이는 락에 의한 대기 시간 없이 트랜잭션을 처리할 수 있기 때문입니다.<br>
반면, 비관적락은 데이터 충돌의 빈도가 높거나 트랜잭션의 안정성이 중요한 경우에 유리합니다.<br>
트랜잭션이 데이터에 접근하면서 바로 해당 데이터를 잠그므로, 다른 트랜잭션이 동시에 접근하는 것을 방지하게 됩니다.<br>
이로 인해 데이터의 동시 변경을 막아서 충돌을 미연에 방지할 수 있고, 충돌로 인한 롤백이나 재처리와 같은 추가적인 비용을 줄일 수 있습니다<br>

### 4.장진영 - 동시성 제어 + 프로세스와 스레드
프로세스란 단순히 실행 중인 프로그램이다. -> 메모리 공간을 할당받아 실행 중인 것<br>
스레드란 프로세스 내에서 실제로 작업을 수행하는 주체 -> 프로세스에는 한 개 이상이 스레드가 존재 및 작업<br>

##### 꼬리질문 1. 스레드 풀이 무엇인지, 사용은 어떻게 처리되는지, 실제 프로젝트에서 관리를 해본 적 있는지 이야기해주세요.
스레드 풀은 미리 생성된 스레드 집합을 관리합니다. 스레드의 재사용을 통해 시스템 부하를 감소시켜 성능 향상에 용이합니다.<br>
(실제 프로젝트에서 webClient나 restTemplate를 사용했다면 Threadpool을 관리하는 코드를 작성해보면 쓰레드 관련 꼬리 질문이 나올 것으로 예상)<br>

##### 꼬리질문 2. Synchronized를 통해 동시성 문제에 대해 해결하려고 했을 때 장단점을 설명해주세요.(동시성 제어 관련해서 LOCK이나 Synchronized를 해결했을 때 꼬리질문 예상)
Synchronized 키워드는 메서드가 한 번에 하나의 스레드에서만 실행할 수 있도록하기 때문에 동시성 제어를 할 수 있으나 성능이 매우 비효율적이기 때문에 사용하지 않을 것 같습니다.<br>
##### 꼬리질문 3. 데드락(Deadlock)이란 무엇이며, 어떻게 방지하거나 해결할 수 있을지 이야기해주세요.
데드락은 두 개 이상의 스레드나 프로세스가 자원을 점유하고 다른 스레드나 프로세스가 필요로 하는 자원을 가지고 있어 상호 블로킹 상태에 놓이는 상황을 말합니다.<br>
데드락을 방지하거나 해결하기 위해 상호 배제, 점유 대기, 비선점, 순환 대기 등을 사용합니다. (꼬리 질문 예상) <br>

---

## 라이브 코딩 주제 및 코드

### DP를 사용한 풀이 (스터디 팀 전원 풀이 실패 - 답안참고)
```java
class Solution {
    public long solution(int cap, int n, int[] deliveries, int[] pickups) {
        long answer = 0;
        
        //각 집에 대한 누적 배달 및 수거 상자 개수 추적
        int deliver = 0, pickup = 0;

        // 역방향으로 집을 순회 (최단거리니까)
        for (int i = n - 1; i >= 0; i--) {
            int count = 0;
            deliver -= deliveries[i];
            pickup -= pickups[i];
        
            // 각 집에서 배달 및 수거 상자를 처리하면서
            // cap을 초과하는 경우 (음수 값) 트럭이 한번에 이동못함
            // 따라서 count 변수를 사용하여 트럭을 이동하는 횟수를 추적
            while (deliver < 0 || pickup < 0) {
                count++;
                deliver += cap;
                pickup += cap;
            }
            // answer 변수는 각 집에서의 이동 거리를 누적
            // count는 트럭을 이동하는 횟수
            // 2 는 왕복을 나타냄
            // (i + 1)은 현재 집까지의 거리를 나타냄.(인덱스+1)
            answer += count * 2 * (i + 1);
        }
        return answer;
    }
}
```

---

### 5주차 계획 - 23.11.02.목(20시~)
- 프로그래머스 라이브코딩 (주제 : DP(2))
- 면접 대비 주제 : JAVA
    
