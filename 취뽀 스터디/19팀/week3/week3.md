# 19팀 취뽀 스터디 3주차 (2023.10.23 ~ 2023.10.29)

---
## 일시
### 23.10.26.목(20:30~22시)
- 프로그래머스 라이브코딩 주제 : [타켓넘버 LV.2](https://school.programmers.co.kr/learn/courses/30/lessons/43165)
- 면접 대비 주제 : OS (예상질문 및 모범답안, 꼬리질문 논의 및 공유)
- 참여자: 조현수, 최병호, 김상훈, 김동역, 장진영
        
---
## 기술면접 질문

### 1. 김상훈 - 프로세스 주소 공간의 구조 및 분리에 대한 질문 

프로그램이 CPU에 의해 실행됨 → 프로세스가 생성되고 메모리에 프로세스 주소 공간이 할당됨<br>
프로세스 주소 공간에는 코드, 데이터, 스택으로 이루어져 있다.<br>
코드 Segment : 프로그램 소스 코드 저장<br>
데이터 Segment : 전역 변수 저장<br>
스택 Segment : 함수, 지역 변수 저장<br>
예상 질문 : 이렇게 나눈 이유?<br>
최대한 데이터를 공유하여 메모리 사용량을 줄여야 한다.<br>
코드는 같은 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유한다.<br>
Stack과 data를 나눈 이유는, 스택 구조의 특성과 전역 변수의 활용성을 위한 것이다.<br>
프로그램의 함수와 지역 변수는, LIFO(가장 나중에 들어간게 먼저 나옴)특성을 가진 스택에서 실행된다.<br>
따라서 이 함수들 안에서 공통으로 사용하는 '전역 변수'는 따로 지정해주면 메모리를 아낄 수 있다.

### 2. 김동역 - 교착상대에 대한 질문 

경쟁 상태와 임계 영역<br>
여러 프로세스 또는 스레드에서 하나의 공유 자원에 접근하는 경우가 있는데, 이 때 이 접근 순서에 따라 결과가 달라질 수 있다. <br>
이런 현상을 동시에 접근해 경쟁하는 상태라고 하여 경쟁 상태라고 하고, <br>
위에서 말한 접근 순서에 따라 결과가 달라지는 코드 영역을 임계 영역이라고 한다. <br>
임계 영역에 여러 접근이 동시에 발생하는 것을 방지하려면 다음 3가지 조건을 충족해야 한다.<br>
* 		상호배제 기법(mutual exclusive) : 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없다. 상호배제 기법으로는 뮤텍스와 세마포어가 있다.<br>
* 		진행 : 임계 영역을 실행중인 프로세스가 없을 때 다른 프로세스가 임계 영역을 실행한다.<br>
* 		한정된 대기 : 임계 영역에 접근을 요청할 때 무한한 시간을 기다리지 않는다.<br>
뮤텍스(mutex)<br>
상호배제(mutual exclusive) 에서 단어를 가져온 기법으로, 락(lock)을 가진 프로세스만이 공유 자원에 접근할 수 있게 하는 방법이다. <br>
임계 영역에 먼저 접근한 프로세스가 임계 영역에 락을 걸면 다른 프로세스들은 해당 프로세스가 락을 해제하기 전까지 기다려야 한다.<br>
임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리면서 락이 풀렸는지 반복문을 돌면서 확인한다. 이를 바쁜 대기의 한 종류인 스핀락(spinlock)이라고 한다. <br>
프로세스가 반복문을 돌면서 계속 자원의 사용 가능 여부를 확인하므로 프로세스가 빠르게 교체될 수 있다.<br>

바쁜 대기(busy waiting)란, 프로세스가 공유 자원에 접근할 수 있는 권한을 얻을 때 까지 확인하는 과정을 말한다.<br>
교착 상태(deadlock)<br>
상호배제 기법 때문에 2개 이상의 프로세스가 각각 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태를 교착 상태(deadlock)라고 한다. <br>
교착 상태가 발생하는 필요충분조건(프로세스들이 각각의 조건을 모두 가지거나 모두 아니어야 한다.) 4가지는 다음과 같다.<br>
* 		상호배제 : 하나의 공유 자원에 하나의 프로세스만 접근할 수 있다.<br>
* 		점유와 대기 : 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용 중인 자원을 점유하기 위해 대기한다.<br>
* 		비선점 : 다른 프로세스에 할당된 자원을 뺏을 수 없다.<br>
* 		원형 대기 : 프로세스가 자신의 자원을 점유하면서 앞이나 뒤의 프로세스의 자원을 요구한다.<br>
예상 질문<br>
상호배제 기법에 뮤텍스와 세마포어가 있는데, 각각에 대해 설명해 보세요.<br>
뮤텍스는 락을 가진 프로세스만 공유 자원에 접근할 수 있습니다. 임계 영역에 접근할 수 있는 프로세스는 하나뿐이며,<br>
다른 프로세스는 임계 영역에 접근한 프로세스가 락을 해제할 때까지 기다려야 합니다. <br>
반면 세마포어는 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법입니다. <br>
임계 영역에 접근할 수 있는 키 n개(2개 이상, 1개라면 뮤텍스와 차이점이 없음)를 지정하고 이 키를 가진 프로세스만이 임계 영역에 접근하게 하는 방식입니다.<br>

#### 꼬리질문 1. 교착 상태를 예방할 수 있는 방법을 설명해 보세요.

교착 상태를 막으려면 교착 상태가 발생하는 4가지 조건 중 하나를 제거하면 됩니다. <br>
즉 여러 프로세스가 동시에 하나의 공유 자원을 사용하게 하거나(상호배제 제거), <br>
프로세스가 실행되기 전에 필요한 모든 자원을 할당하여 프로세스 대기를 없애고 프로세스가 자원을 점유하지 않은 상태에만 자원을 요구하게 하거나(점유/대기 제거), <br>
자원을 점유한 프로세스가 다른 자원을 요구 할 때 현재 점유한 자원을 반환하게 하거나(비선점 제거), <br>
자원을 선형으로 정렬하고 방향을 정해 한 쪽 방향으로만 자원을 요구하게 하면(원형 대기 제거) 교착 상태를 예방할 수 있습니다.<br>

### 3. 조현수 - 프로세스와 스레드의 차이를 설명해주세요.

프로세스란 운영체제에서 실행 중인 프로그램으로 운영체제로부터 CPU,메모리 공간 등의 시스템 자원을 할당받아 작업을 수행합니다.<br>
스레드는 한 프로세스 내의 실행 단위를 뜻합니다.<br>
스레드 ID, PC, 레지스터 집합, 스택(이 4가지로 구성되었다고 봐도됨)은 독립적으로 할당되고 나머지 (프로세스)자원들은 공유하며 사용하는 것이 특징입니다.<br>
참고<br>
같은 프로세스의 다른 스레드와는 코드 영역, 데이터 영역, 운영체제 자원등을 공유함.<br>
프로세스의 경우 각각 code,data,stack,heap을 보유하기에 동기화 작업이 필요하지 않지만, 각각의 영역을 가져서 컨텍스트 스위칭 비용이 크다.<br>
스레드는 stack만 고유 영역을 가지고, 나머지는 프로세스 자원을 공유<br>
stack 이외의 영역을 공유하므로, 동기화 작업이 필요하지만, 컨텍스트 스위칭 비용이 적음<br>
각각의 실행 위치를 알려주기 위해 PC를, 수행중인 값을 임시적으로 저장하기 위한 레지스터 집합 공간을 별도로 가져야 합니다<br>

#### 꼬리질문 1 .스레드마다 스택을 독립적으로 할당하는 이유가 뭐죠?

스택을 사용하여 함수 호출 시의 인자, 반환 주소, 지역 변수 등을 저장합니다.<br>
스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능함을 의미하고 이는 독립적인 실행 흐름이 추가된다는 것을 의미합니다. <br>
즉, 독립적인 실행 흐름을 만들기 위해서 스레드마다 스택을 할당합니다.<br>

---
## 라이브 코딩 주제 및 코드

### DP를 사용한 풀이 (최병호)
```java
class Solution {
    int n;
    int offset;
    int[][] dp;

    public int solution(int[] numbers, int target) {
        n = numbers.length;
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        offset = sum;
        dp = new int[n + 1][2 * offset + 1];
        return getDp(0, 0, numbers, target);
    }

    public int getDp(int idx, int currentSum, int[] numbers, int target) {
        if (idx == n) {
            return (currentSum == target) ? 1 : 0;
        }

        if (dp[idx][currentSum + offset] != 0) {
            return dp[idx][currentSum + offset];
        }

        int curNumb = numbers[idx];
        int result = getDp(idx + 1, currentSum + curNumb, numbers, target) +
                     getDp(idx + 1, currentSum - curNumb, numbers, target);

        dp[idx][currentSum + offset] = result;
        return result;
    }
}
```

### DFS를 활용한 풀이 (김동역,김상훈,장진영,조현수)
```
class Solution {
    
    static int answer = 0;
    
    static void DFS(int[] numbers, int index, int sum, int target) {
        // 모든 연산이 끝난 마지막 노드에서
        if (index == numbers.length) {
            // 합이 타겟 노드이면 방법의 수 추가
            if (sum == target) {
                answer++;
            }
        // 아니면 더하거나 뺀 수를 다시 반영하여 탐색
        } else {
            DFS(numbers, index + 1, sum + numbers[index], target);
            DFS(numbers, index + 1, sum - numbers[index], target);
        }
    }
    
    public int solution(int[] numbers, int target) {
        DFS(numbers, 0, 0, target);
        return answer;
    }
}
```

---

### 4주차 계획 - 23.11.02.목(20시~)
- 프로그래머스 라이브코딩 (주제 : BFS)
- 면접 대비 주제 : DB(2) 트랜잭션 (예상질문 및 모범답안, 꼬리질문 논의 및 공유)
    
